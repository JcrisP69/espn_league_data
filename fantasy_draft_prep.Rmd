---
title: "Fantasy Draft Prep"
author: "Julien Gagnaire"
date: "2024-08-23"
output: pdf_document
---

```{r setup, include=FALSE}

# Loading packages :
# Used to knit the document into pdf
library(latexpdf)
# Used for importing excel sheets
library(readxl)
# Used for modifying data
library(dplyr)
# Used to get more advanced descriptives
library(ggplot2)
# Used to knit documents
library(knitr)
library(tinytex)
# scatterplot function
library(car)

# unsure of the use :

library(plm)
library(sandwich)
library(zoo)
library(tidyverse)
library(funModeling)
library(VIM)
```



```{r import dataset , include=FALSE}
#loading excel sheets
draft_2022 <- read_excel("C:/Users/Julien/Desktop/data_analysis/data/final_nfl_fantasy.xlsx", 
                             sheet = "draft_2022")
draft_2023 <- read_excel("C:/Users/Julien/Desktop/data_analysis/data/final_nfl_fantasy.xlsx", 
                             sheet = "draft_2023")
stats_2022 <- read_excel("C:/Users/Julien/Desktop/data_analysis/data/final_nfl_fantasy.xlsx", 
                             sheet = "stats_2022")
stats_2023 <- read_excel("C:/Users/Julien/Desktop/data_analysis/data/final_nfl_fantasy.xlsx", 
                             sheet = "stats_2023")
proj_2023 <- read_excel("C:/Users/Julien/Desktop/data_analysis/data/final_nfl_fantasy.xlsx", 
                             sheet = "proj_2023")
proj_2024 <- read_excel("C:/Users/Julien/Desktop/data_analysis/data/final_nfl_fantasy.xlsx", 
                             sheet = "proj_2024")
trends_2024 <- read_excel("C:/Users/Julien/Desktop/data_analysis/data/final_nfl_fantasy.xlsx", 
                             sheet = "trends_2024")
```

# Introductory study of the data

The following document utilises data from different aspects of the M9B fantasy
nfl draft. Fantasy stats, fantasy projections, seasonal results and draft orders
are some of the data points used to create useful insights to optimize draft
strategy starting in the 2024-25 seeason.

## Missing data, duplicates and other formatting issues

Missing data is found in the 2024 projections sheet :

```{r missing data, echo=FALSE, fig.height=4, fig.width=4}
na_study <- aggr(proj_2024,
                 col=c('grey','darkred'),
                 labels=names(data),
                 cex.axis=.7, gap=3,
                 ylab=c("Missing data","Patterns"))
```

Consequently, the players with missing data will be removed from the analysis,
hopefully by draft day all the data will be available. The missing data is found 
in players that are retired or having had season ending injuries

```{r, include=FALSE}
# Deleting the observations missing data
proj_2024 <- na.omit(proj_2024)
```


```{r, include=FALSE}

#Setting the appropriate classes to variables

draft_2022 <- mutate_at(draft_2022, "buyer", as.factor)
draft_2023 <- mutate_at(draft_2023, "buyer", as.factor)

stats_2022 <- mutate_at(stats_2022, "pos", as.factor)
stats_2023 <- mutate_at(stats_2023, "pos", as.factor)

proj_2023 <- mutate_at(proj_2023, "pos", as.factor)
proj_2024 <- mutate_at(proj_2024, "pos", as.factor)

#Setting the appropriate amount of each pos to consider for the draft
noDST <- 8
noK <- 8
noQB <- 8
noRB <- 16
noTE <- 8
noWR <- 16 
noFLEX <- 40
```


# Visualisation

## Delemitation of Tiers

We can make a study of Vorp by calculating the differential between draft
options.

```{r, echo=FALSE, fig.width=7, fig.height=3}

trend_proj_2024 <- inner_join(trends_2024, proj_2024, by = "name")

# Group by 'pos' and calculate the differences
trend_proj_2024 <- trend_proj_2024 %>%
  group_by(pos) %>%
  mutate(max_value = max(tot),
         dif = max_value - tot)

# Split the dataframe by 'pos'
subset_trend_proj_2024 <- split(trend_proj_2024, trend_proj_2024$pos)

# Loop through each subset and plot
for (pos_name in names(subset_trend_proj_2024)) {
  subset_data <- subset_trend_proj_2024[[pos_name]]
  
  # Create the scatterplot
  scatterplot(dif ~ salary,
              main = paste(pos_name),
              ylab = "Difference from max (dif)",
              xlab = "Salary",
              boxplots = FALSE,
              smooth = TRUE,
              regLine = FALSE,
              data = subset_data)
}
```

```{r}
scatterplot(dif ~ salary,
              main = "Overview",
              ylab = "Difference from max (dif)",
              xlab = "Salary",
              boxplots = FALSE,
              smooth = TRUE,
              regLine = FALSE,
              data = trend_proj_2024,
            groups = trend_proj_2024$pos)
```

Here is a k-means clustering for 8 tiers of the projected highest dif starting 
players

```{r dif tiers, echo=FALSE}

# Remaking the dataframe
trend_proj_2024 <- inner_join(trends_2024, proj_2024, by = "name")

# Initial ordering
trend_proj_2024 <- trend_proj_2024[order(trend_proj_2024$tot, decreasing = TRUE), ]

# Select the appropriate number of players
obs_to_keep  <- c(`D/ST`= noDST, 
                  K = noK,
                  QB = noQB,
                  RB = noRB,
                  TE = noTE, 
                  WR = noWR)

# Filter the dataframe
trend_proj_2024 <- trend_proj_2024 %>%
  group_by(pos) %>%
  filter(row_number() <= obs_to_keep[pos]) %>%
  ungroup()  # Remove grouping
  
# Group by 'pos' and calculate the differences
trend_proj_2024 <- trend_proj_2024 %>%
  group_by(pos) %>%
  mutate(max_value = max(tot),
         dif = max_value - tot) %>%
ungroup()

# Use k-means clustering to divide the data into k tiers
k <- 8  # Define the number of tiers
kmeans_result <- kmeans(trend_proj_2024$dif, centers = k)

# Add cluster membership (tiers) to the data
trend_proj_2024$tier <- kmeans_result$cluster

# Reorder tiers so that the highest `tot` values correspond to the highest tiers
# Determine the mean `tot` for each cluster
mean_tot_per_cluster <- tapply(trend_proj_2024$dif, trend_proj_2024$tier, mean)

# Create a vector of tiers ordered by mean `tot` in descending order
ordered_tiers <- order(mean_tot_per_cluster, decreasing = FALSE)

# Map original tiers to new tier numbers
trend_proj_2024$tier <- factor(trend_proj_2024$tier, levels = ordered_tiers, labels = seq_along(ordered_tiers))

# Convert `tier` to numeric for plotting
trend_proj_2024$tier <- as.numeric(as.character(trend_proj_2024$tier))

# Sort the data by `dif` in decreasing order
trend_proj_2024 <- trend_proj_2024[order(trend_proj_2024$dif, decreasing = FALSE), ]

# Check the resulting tiers
scatterplot(tier~dif,
     xlab = "Dif",
     ylab = "Tier",
     main = "Total vs. Tier",
     boxplots=FALSE,
     smooth=FALSE,
     regLine=FALSE,
     data = trend_proj_2024,
     groups = trend_proj_2024$pos)

```

## Bid vs stats

### Bid vs stats for 2022

```{r bid vs stats 2022, echo=FALSE, fig.height=3, fig.width=7}

# Just a normal graph
bid_stats_2022 <- inner_join(draft_2022, stats_2022, by = "name")

subset_bid_stats_2022 <- split(bid_stats_2022, bid_stats_2022$pos)

for(pos_name in names(subset_bid_stats_2022)) {
  subset_data <- subset_bid_stats_2022[[pos_name]]
  
  
scatterplot(bid~fpts,
          main = paste(pos_name),
          ylab = "bid",
          xlab = "fpts",
          boxplots=FALSE,
            smooth=TRUE,
            regLine=FALSE,
          data = subset_data)
}
```

### Bid vs stats for 2023

```{r bid vs stats 2023, echo=FALSE, fig.height=3, fig.width=7}

# Just a normal graph
bid_stats_2023 <- inner_join(draft_2023, stats_2023, by = "name")

subset_bid_stats_2023 <- split(bid_stats_2023, bid_stats_2023$pos)

for(pos_name in names(subset_bid_stats_2023)) {
  subset_data <- subset_bid_stats_2023[[pos_name]]
  
  
scatterplot(bid~fpts,
          main = paste(pos_name),
          ylab = "bid",
          xlab = "fpts",
          boxplots=FALSE,
            smooth=TRUE,
            regLine=FALSE,
          data = subset_data)
}
```


### Bid vs proj 2023

```{r bid vs proj 2023, echo=FALSE, fig.height=3, fig.width=7, warning=FALSE}

# Just a normal graph
bid_proj_2023 <- inner_join(draft_2023, proj_2023, by = "name")

subset_bid_proj_2023 <- split(bid_proj_2023, bid_proj_2023$pos)

for(pos_name in names(subset_bid_proj_2023)) {
  subset_data <- subset_bid_proj_2023[[pos_name]]
  
  
scatterplot(bid~tot,
          main = paste(pos_name),
          ylab = "bid",
          xlab = "tot",
          boxplots=FALSE,
            smooth=TRUE,
            regLine=FALSE,
          data = subset_data)
}
```

## Analysis

$$fpts_{i} = \beta_0 + \beta_1 bid_{i} +\epsilon_{i,t}$$

```{r regression model 1, echo=FALSE}

# GLM
model_1 <- full_join(bid_stats_2022, bid_stats_2023)

model_1 <- split(model_1, model_1$pos)

glm_models <- list()

# Loop over each subset of the data
for (pos in names(model_1)) {
  # Fit the GLM model for each subset (e.g., logistic regression)
  # Assuming 'fpts' is the dependent variable and 'bid' is the independent variable
  glm_models[[pos]] <- glm(fpts ~ bid, data = model_1[[pos]])
  
  # Print the summary of each GLM model
  cat("\nSummary for position:", pos, "\n")
  print(summary(glm_models[[pos]]))
}

#results <- glm(fpts~bid, data = model_1[['WR']])
#summary(results)

```

## The algorithmic method to determine the best possible team

```{r draft algo setup, include=FALSE}

trend_proj_2024 <- inner_join(trends_2024, proj_2024, by = "name")
trend_proj_2024 <- subset(trend_proj_2024, trend_proj_2024$salary != 0)
trend_proj_2024 <- subset(trend_proj_2024, trend_proj_2024$tot != 0)

subset_trend_proj_2024 <- split(trend_proj_2024, trend_proj_2024$pos)
subset_trend_proj_2024$FLEX <- c(subset_trend_proj_2024$RB,
                              subset_trend_proj_2024$TE,
                               subset_trend_proj_2024$WR)

capacity <- 200

weights <- list(
  subset_trend_proj_2024$`D/ST`$salary,
  subset_trend_proj_2024$K$salary,
  subset_trend_proj_2024$QB$salary,
  subset_trend_proj_2024$RB$salary,
  subset_trend_proj_2024$RB$salary,
  subset_trend_proj_2024$TE$salary,
  subset_trend_proj_2024$WR$salary,
  subset_trend_proj_2024$WR$salary,
  subset_trend_proj_2024$FLEX$salary
  )

values <- list(
  subset_trend_proj_2024$`D/ST`$tot,
  subset_trend_proj_2024$K$tot,
  subset_trend_proj_2024$QB$tot,
  subset_trend_proj_2024$RB$tot,
  subset_trend_proj_2024$RB$tot,
  subset_trend_proj_2024$TE$tot,
  subset_trend_proj_2024$WR$tot,
  subset_trend_proj_2024$WR$tot,
  subset_trend_proj_2024$FLEX$tot
  )

names <- list(
  subset_trend_proj_2024$`D/ST`$name,
  subset_trend_proj_2024$K$name,
  subset_trend_proj_2024$QB$name,
  subset_trend_proj_2024$RB$name,
  subset_trend_proj_2024$RB$name,
  subset_trend_proj_2024$TE$name,
  subset_trend_proj_2024$WR$name,
  subset_trend_proj_2024$WR$name,
  subset_trend_proj_2024$FLEX$name
  )

# Define the dynamic knapsack function for maximization with item names
dynamic_knapsack_by_category_max <- function(weights, values, categories, names, capacity) {
  
  # Get the number of categories
  num_categories <- length(categories)
  
  # Initialize a matrix to store the maximum values
  dp <- matrix(0, nrow = num_categories + 1, ncol = capacity + 1)
  
  # Create a list to store the picked items for backtracking
  picked_items <- matrix(0, nrow = num_categories + 1, ncol = capacity + 1)
  
  # Fill the DP table category by category
  for (c in 1:num_categories) {
    # Extract the items for the current category
    category_weights <- weights[[c]]
    category_values <- values[[c]]
    num_items_in_category <- length(category_weights)
    
    # Create a temporary copy of the current dp row to use for updates
    dp_temp <- dp[c, ]
    picked_temp <- picked_items[c, ]
    
    # Iterate over the current capacity from 0 to maximum capacity
    for (w in 0:capacity) {
      # For each item in the category, check if it can be included
      for (i in 1:num_items_in_category) {
        if (category_weights[i] <= w) {
          new_value <- dp[c, w + 1 - category_weights[i]] + category_values[i]
          # Update dp_temp if including this item gives a better result
          if (new_value > dp_temp[w + 1]) {
            dp_temp[w + 1] <- new_value
            picked_temp[w + 1] <- i  # Track the item picked
          }
        }
      }
    }
    
    # Move to the next category by updating dp[c+1] and picked_items[c+1]
    dp[c + 1, ] <- dp_temp
    picked_items[c + 1, ] <- picked_temp
  }
  
  # The maximum value is in dp[num_categories + 1, capacity + 1]
  max_value <- dp[num_categories + 1, capacity + 1]
  
  # Backtrack to find which items were picked
  selected_items <- c()
  selected_names <- c()
  remaining_capacity <- capacity
  
  for (c in num_categories:1) {
    item_index <- picked_items[c + 1, remaining_capacity + 1]
    selected_items <- c(item_index, selected_items)  # Prepend the picked item index
    selected_names <- c(names[[c]][item_index], selected_names)  # Prepend the picked item name
    remaining_capacity <- remaining_capacity - weights[[c]][item_index]  # Adjust the remaining capacity
  }
  
  # Return the result as a list with the maximum value, selected items, and names
  return(list(max_value = max_value, selected_items = selected_items, selected_names = selected_names))
}

# Define the number of categories
categories <- 1:length(weights)  # Here, we have 3 categories

# Call the dynamic knapsack function for maximization
result <- dynamic_knapsack_by_category_max(weights, values, categories, names, capacity)

# Output the result
cat("The maximum value that can be achieved by choosing exactly one item per category is:", result$max_value, "\n")
# cat("The selected items (by index) for each category are:", result$selected_items, "\n")
cat("The selected item names are:", result$selected_names, "\n")


```

```{r draft algo duplicates, include=FALSE}
dupe <- result$selected_items[4]

# Delete the player already selected in one pos
weights[5] <- weights[[5]][-dupe]
values[5] <- values[[5]][-dupe]
names[5] <- names[[5]][-dupe]

dupe <- result$selected_items[5]

# Delete the player already selected in one pos
weights[4] <- weights[[4]][-dupe]
values[4] <- values[[4]][-dupe]
names[4] <- names[[4]][-dupe]

```

```{r draft algo output, echo=FALSE}
# Call the dynamic knapsack function for maximization
result <- dynamic_knapsack_by_category_max(weights, values, categories, names, capacity)

# Output the result
cat("The maximum value that can be achieved by choosing exactly one item per category is:", result$max_value, "\n")
# cat("The selected items (by index) for each category are:", result$selected_items, "\n")
cat("The selected item names are:", result$selected_names, "\n")

```

